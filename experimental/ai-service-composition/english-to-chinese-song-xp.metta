;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define <=
(: <= (-> $a $a Bool))
(= (<= $x $y) (or (< $x $y) (== $x $y)))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: Z' DeBruijn)                        ; Zero
(: S' (-> DeBruijn DeBruijn))          ; Successor

;;;;;;;;;;
;; List ;;
;;;;;;;;;;

;; Declaration of List data type and constructors
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;;;;;;;;;;;;;;;;;;;;;
;; Match over list ;;
;;;;;;;;;;;;;;;;;;;;;

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

;; Test match' on empty list
!(assertEqualToResult
  (match' Nil ($x $y) ($y $x))
  ())

;; Test match' on singleton
!(assertEqual
  (match' (Cons (A B) Nil) ($x $y) ($y $x))
  (B A))

;; Test match' on pair
!(assertEqualToResult
  (match' (Cons (A B) (Cons (C D) Nil)) ($x $y) ($y $x))
  ((B A)
   (D C)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: for now we paste the content of
;; english-song-to-chinese-song-services.metta here because the import
;; operation imports the stdlib as well and let stdlib functions being
;; used as rules and axioms by the backward chainer.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Services involved in creating a composite service to turn English
;; singing into Chinese singing.
;;
;; The service specifications are obtained from the output of
;;
;; ./gen-snet-marketplace-metta.sh naint.machine-translation naint.midi2voice-zh snet.sound-spleeter snet.speech-recognition
;;
;; then curated to retain only the information about the type
;; signatures of service calls.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: translate.proto
;; Protobuf syntax: proto3
;; Prefix: naint.machine-translation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; Message Types ;;
;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;
;; Input ;;
;;;;;;;;;;;

!(bind! &kb (new-space))

;; Define naint.machine-translation.Input type
!(add-atom &kb (: naint.machine-translation.Input Type))

;; Define naint.machine-translation.Input constuctor
!(add-atom &kb (: naint.machine-translation.MkInput
   (-> String ; source_lang
       (-> String ; target_lang
           (-> String ; sentences_url
               naint.machine-translation.Input)))))
;; Define naint.machine-translation.Input access functions

;; Define naint.machine-translation.Input.source_lang
!(add-atom &kb (: naint.machine-translation.Input.source_lang
   (-> naint.machine-translation.Input String)))

;; Define naint.machine-translation.Input.target_lang
!(add-atom &kb (: naint.machine-translation.Input.target_lang
   (-> naint.machine-translation.Input String)))

;; Define naint.machine-translation.Input.sentences_url
!(add-atom &kb (: naint.machine-translation.Input.sentences_url
   (-> naint.machine-translation.Input String)))

;;;;;;;;;;;;
;; Output ;;
;;;;;;;;;;;;

;; Define naint.machine-translation.Output type
!(add-atom &kb (: naint.machine-translation.Output Type))

;; Define naint.machine-translation.Output constuctor
!(add-atom &kb (: naint.machine-translation.MkOutput
   (-> String ; translation
       naint.machine-translation.Output)))
;; Define naint.machine-translation.Output access functions

;; Define naint.machine-translation.Output.translation
!(add-atom &kb (: naint.machine-translation.Output.translation
   (-> naint.machine-translation.Output String)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;
;; RomanceTranslator ;;
;;;;;;;;;;;;;;;;;;;;;;;

;; Define naint.machine-translation.translate service method
!(add-atom &kb (: naint.machine-translation.translate
   (-> naint.machine-translation.Input naint.machine-translation.Output)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: singingZH.proto
;; Protobuf syntax: proto3
;; Protobuf package: singingZH
;; Prefix: naint.midi2voice-zh
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; Message Types ;;
;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;
;; Query ;;
;;;;;;;;;;;

;; Define naint.midi2voice-zh.Query type
!(add-atom &kb (: naint.midi2voice-zh.Query Type))

;; Define naint.midi2voice-zh.Query constuctor
!(add-atom &kb (: naint.midi2voice-zh.MkQuery
   (-> String ; text
       (-> Bytes ; midi_file
           (-> Float ; normalize
               naint.midi2voice-zh.Query)))))
;; Define naint.midi2voice-zh.Query access functions

;; Define naint.midi2voice-zh.Query.text
!(add-atom &kb (: naint.midi2voice-zh.Query.text
   (-> naint.midi2voice-zh.Query String)))

;; Define naint.midi2voice-zh.Query.midi_file
!(add-atom &kb (: naint.midi2voice-zh.Query.midi_file
   (-> naint.midi2voice-zh.Query Bytes)))

;; Define naint.midi2voice-zh.Query.normalize
!(add-atom &kb (: naint.midi2voice-zh.Query.normalize
   (-> naint.midi2voice-zh.Query Float)))

;;;;;;;;;;;;
;; Answer ;;
;;;;;;;;;;;;

;; Define naint.midi2voice-zh.Answer type
!(add-atom &kb (: naint.midi2voice-zh.Answer Type))

;; Define naint.midi2voice-zh.Answer constuctor
!(add-atom &kb (: naint.midi2voice-zh.MkAnswer
   (-> Bytes ; output_audio
       naint.midi2voice-zh.Answer)))
;; Define naint.midi2voice-zh.Answer access functions

;; Define naint.midi2voice-zh.Answer.output_audio
!(add-atom &kb (: naint.midi2voice-zh.Answer.output_audio
   (-> naint.midi2voice-zh.Answer Bytes)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;
;; singingZH ;;
;;;;;;;;;;;;;;;

;; Define naint.midi2voice-zh.singingZH service method
!(add-atom &kb (: naint.midi2voice-zh.singingZH
   (-> naint.midi2voice-zh.Query naint.midi2voice-zh.Answer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: sound_spleeter.proto
;; Protobuf syntax: proto3
;; Prefix: snet.sound-spleeter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; Message Types ;;
;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;
;; Input ;;
;;;;;;;;;;;

;; Define snet.sound-spleeter.Input type
!(add-atom &kb (: snet.sound-spleeter.Input Type))

;; Define snet.sound-spleeter.Input constuctor
!(add-atom &kb (: snet.sound-spleeter.MkInput
   (-> String ; audio_url
       (-> Bytes ; audio
           snet.sound-spleeter.Input))))
;; Define snet.sound-spleeter.Input access functions

;; Define snet.sound-spleeter.Input.audio_url
!(add-atom &kb (: snet.sound-spleeter.Input.audio_url
   (-> snet.sound-spleeter.Input String)))

;; Define snet.sound-spleeter.Input.audio
!(add-atom &kb (: snet.sound-spleeter.Input.audio
   (-> snet.sound-spleeter.Input Bytes)))

;;;;;;;;;;;;
;; Output ;;
;;;;;;;;;;;;

;; Define snet.sound-spleeter.Output type
!(add-atom &kb (: snet.sound-spleeter.Output Type))

;; Define snet.sound-spleeter.Output constuctor
!(add-atom &kb (: snet.sound-spleeter.MkOutput
   (-> Bytes ; vocals
       (-> Bytes ; accomp
           snet.sound-spleeter.Output))))
;; Define snet.sound-spleeter.Output access functions

;; Define snet.sound-spleeter.Output.vocals
!(add-atom &kb (: snet.sound-spleeter.Output.vocals
   (-> snet.sound-spleeter.Output Bytes)))

;; Define snet.sound-spleeter.Output.accomp
!(add-atom &kb (: snet.sound-spleeter.Output.accomp
   (-> snet.sound-spleeter.Output Bytes)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; SoundSpleeter ;;
;;;;;;;;;;;;;;;;;;;

;; Define snet.sound-spleeter.spleeter service method
!(add-atom &kb (: snet.sound-spleeter.spleeter
   (-> snet.sound-spleeter.Input snet.sound-spleeter.Output)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa representation, generated by protobuf-metta
;;
;; Protobuf file: asr.proto
;; Protobuf syntax: proto3
;; Protobuf package: asr
;; Prefix: snet.speech-recognition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;; Message Types ;;
;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;
;; Audio ;;
;;;;;;;;;;;

;; Define snet.speech-recognition.Audio type
!(add-atom &kb (: snet.speech-recognition.Audio Type))

;; Define snet.speech-recognition.Audio constuctor
!(add-atom &kb (: snet.speech-recognition.MkAudio
   (-> Bytes ; data
       snet.speech-recognition.Audio)))
;; Define snet.speech-recognition.Audio access functions

;; Define snet.speech-recognition.Audio.data
!(add-atom &kb (: snet.speech-recognition.Audio.data
   (-> snet.speech-recognition.Audio Bytes)))

;;;;;;;;;;
;; Text ;;
;;;;;;;;;;

;; Define snet.speech-recognition.Text type
!(add-atom &kb (: snet.speech-recognition.Text Type))

;; Define snet.speech-recognition.Text constuctor
!(add-atom &kb (: snet.speech-recognition.MkText
   (-> String ; text
       snet.speech-recognition.Text)))
;; Define snet.speech-recognition.Text access functions

;; Define snet.speech-recognition.Text.text
!(add-atom &kb (: snet.speech-recognition.Text.text
   (-> snet.speech-recognition.Text String)))

;;;;;;;;;;;;;;
;; Services ;;
;;;;;;;;;;;;;;

;;;;;;;;;
;; ASR ;;
;;;;;;;;;

;; Define snet.speech-recognition.s2t service method
!(add-atom &kb (: snet.speech-recognition.s2t
   (-> snet.speech-recognition.Audio snet.speech-recognition.Text)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Handwrite missing services, ToMidi and Mixer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; ToMidi ;;
;;;;;;;;;;;;

;; Input audio type
!(add-atom &kb (: tomidi.Audio Type))
!(add-atom &kb (: tomidi.MkAudio (-> Bytes ; data
                      tomidi.Audio)))
!(add-atom &kb (: tomidi.Audio.data (-> tomidi.Audio Bytes)))

;; Output MIDI type
!(add-atom &kb (: tomidi.MIDI Type))
!(add-atom &kb (: tomidi.MkMIDI (-> Bytes ; data
                     tomidi.MIDI)))
!(add-atom &kb (: tomidi.MIDI.data (-> tomidi.MIDI Bytes)))

;; Method
!(add-atom &kb (: tomidi.a2m (-> tomidi.Audio tomidi.MIDI)))

;;;;;;;;;;;
;; Mixer ;;
;;;;;;;;;;;

;; Input multi-audio type
!(add-atom &kb (: mixer.MultiAudio Type))
!(add-atom &kb (: mixer.MkMultiAudio (-> Bytes ; data1
                          (-> Bytes ; data2
                              mixer.MultiAudio))))
!(add-atom &kb (: mixer.MultiAudio.data1 (-> mixer.MultiAudio Bytes)))
!(add-atom &kb (: mixer.MultiAudio.data2 (-> mixer.MultiAudio Bytes)))

;; Output MIDI type
!(add-atom &kb (: mixer.Audio Type))
!(add-atom &kb (: mixer.MkAudio (-> Bytes ; data
                     mixer.Audio)))
!(add-atom &kb (: mixer.Audio.data (-> mixer.Audio Bytes)))

;; Method
!(add-atom &kb (: mixer.mix (-> mixer.MultiAudio mixer.Audio)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Other type definitions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Empty string
!(add-atom &kb (: "" String))

;; English language string
!(add-atom &kb (: "English" String))

;; Chinese language string
!(add-atom &kb (: "Chinese" String))

;; Constant float 1.0
!(add-atom &kb (: 1.0 Float))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; The following code is copied from NEXT.

;; Curried Backward Chainer with lambda abstraction.  A lambda
;; abstraction is represented by
;;
;; (λ <INDEX> <BODY>)
;;
;; where <INDEX> is a De Bruijn index as define above, such as Z' or
;; (S' Z'), and <BODY> is a term possibly containing <INDEX>.  Note
;; that the use of De Bruijn index in lambda abstraction is somewhat
;; unconventional here.  It differs from what is described in
;; https://en.wikipedia.org/wiki/De_Bruijn_index in three ways:
;;
;; 1. The index is explicitely attached to a λ by being its first
;;    argument.  For instance the lambda term λx.x, which would
;;    traditionally be represented by λ1 using De Bruijn index, would
;;    be represented here by the MeTTa term (λ Z' Z').
;;
;; 2. As seen in the example above the index here starts at 0,
;;    represented by Z', instead of 1.
;;
;; 3. The index increases as the lambda abstraction gets deeper.  For
;;    instance λx.λy.x, which would traditionally be represented by
;;    λλ2 using De Bruijn index, is represented here by the MeTTa term
;;    (λ Z' (λ (S' Z') Z').
;;
;; This differences are due to the way the proof abstraction recursive
;; step is defined in the bc, as well as the need for having non
;; overlapping pattern matching between the two recursive steps.
;; Specifically, if λ had only one argument, then (λ <BODY>) would
;; overlap with (<ABS> <ARG>).  Having λ take 2 arguments instead of 1
;; has the disadvantage of making lambda abstraction not as compact.
;; On the flip side, the benefit is that the scope of an index is
;; easier to track.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;; * Environment: a list of typing relationship between De Bruijn
;;   index and type, such as
;;
;;   (Cons (: Z' String) (Cons (: (S' Z') Number) Nil))
;;
;; * De Bruijn Index: De Bruijn Index to use if a lambda abstraction
;;   is introduced.
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.  Note that for arguments of
;;   applications must be type annotated (unknowns types are of course
;;   allowed).  For instance the following query
;;
;;   (: (ModusPonens ab) $thrm)
;;
;;   would not work, instead one needs to provide
;;
;;   (: (ModusPonens (: ab $lemma)) $thrm)
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
;;
;; As explained, the proof arguments must be type annotated.  Without
;; such type annotation, lambda abstraction sometimes leads to
;; incorrect results.  It is suspected to come from the fact that
;; otherwise the proof application recursive step loses bindings about
;; the premise.  Having annotated proof is however a good thing, to
;; display a proof tree and to have an indepth view into the proof.
;; In order to remove (resp. add) type annotation one can use
;; remove-type (resp. add-type).
(: bc (-> $a                            ; Knowledge base space
          $b                            ; Environment
          DeBruijn                      ; De Bruijn Index
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   (let* (((: $prfabs (-> $prms $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> $prms $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (λ $idx $prfbdy) (-> $prms $thrm)))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (S' $idx) $k (: $prfbdy $thrm))
     (: (λ $idx $prfbdy) (-> $prms $thrm))))

;;;;;;;;;;;;;;;;;;;;;
;; Remove/add type ;;
;;;;;;;;;;;;;;;;;;;;;

;; Remove type annotations from a query.
;;
;; For instance
;;
;; (remove-type (: ((ModusPonens (: ab (→ A B))) (: a A)) B))
;;
;; outputs
;;
;; ((ModusPonens ab) a)
(: remove-type (-> $a $a))
(= (remove-type $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ;; Only covers up to trinary expression because
                    ;; for now the bc is not supposed to generate
                    ;; n-ary expression where n is greater 3.
                    ((() ())
                     (($x) ((remove-type $x)))
                     (($x $y) ((remove-type $x) (remove-type $y)))
                     (($x $y $z) (if (== $x :)
                                     (remove-type $y)
                                     ((remove-type $x) (remove-type $y) (remove-type $z))))
                     ($_ $_)))))))

;; Add type missing annotation to be compatible with bc query format.
;; Whatever is missing is only added as variables, not inferred, for
;; that one may use the bc.  Note that the first annotation must be
;; provided manually
;;
;; For instance
;;
;; (add-type ((ModusPonens ab) a))
;;
;; only outputs
;;
;; ((ModusPonens (: ab $t#1)) (: a $t#2))
;;
;; not
;;
;; (: ((ModusPonens (: ab $t#1)) (: a $t#2)) $t#3)
;;
;; That is because add-type can only detect application, that is a
;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
(: add-type (-> $a $a))
(= (add-type $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ((() ())
                     (($x) ($x))
                     (($x $y) (if (== $x S')
                                  ;; Treat De Bruijn index atomically
                                  $term
                                  ;; Add type annotation to argument of application
                                  (let $νx (add-type $x) ($νx (: (add-type $y) $t)))))
                     (($x $y $z) (if (== $x :)
                                     ;; Already a type annotation, recurse only on $y
                                     (: (add-type $y) $z)
                                     (if (== $x λ)
                                         ;; Recurse only on body of lambda abstraction
                                         (λ $y (add-type $z))
                                         $term)))
                     ($_ $_)))))))

;;;;;;;;;;
;; Test ;;
;;;;;;;;;;

;; ;; Look for a program that takes a source_lang as String, a
;; ;; target_lang as String, a sentences_url as String and returns a
;; ;; naint.machine-translation.Input.
;; !(assertEqual
;;   (bc &kb Nil Z' (fromNumber 0)
;;       (: $prg
;;          (-> String (-> String (-> String naint.machine-translation.Input)))))
;;   (: naint.machine-translation.MkInput
;;      (-> String (-> String (-> String naint.machine-translation.Input)))))

;; ;; Look for a program that takes au audio stream as Bytes, supposed to
;; ;; be English singing, and return an audio stream as Bytes, supposed
;; ;; to be Chinese singing.
;; Disable because it takes too long
;; !(bc &kb Nil Z' (fromNumber 3) (: $prf (-> Bytes Bytes)))

;; Cannot use assertEqual due to the need for alpha-equivalence (which
;; has been implemented in the combinatory logic experiment in the
;; chaining repository but takes too long to run).
;;
;; TODO: re-enable once Minimal MeTTa is faster.
;;
;; !(add-type (: (λ Z' ((λ (S' Z') ((λ (S' (S' Z')) ((λ (S' (S' (S' Z'))) ((λ (S' (S' (S' (S' Z')))) ((λ (S' (S' (S' (S' (S' Z'))))) (mixer.Audio.data (mixer.mix ((mixer.MkMultiAudio (snet.sound-spleeter.Output.accomp (S' Z'))) (S' (S' (S' (S' (S' Z'))))))))) (naint.midi2voice-zh.Answer.output_audio (naint.midi2voice-zh.singingZH (((naint.midi2voice-zh.MkQuery (S' (S' (S' Z')))) (S' (S' (S' (S' Z'))))) 1.0))))) (tomidi.MIDI.data (tomidi.a2m (tomidi.MkAudio (S' (S' Z'))))))) (naint.machine-translation.Output.translation (naint.machine-translation.translate (((naint.machine-translation.MkInput "English") "Chinese") (snet.speech-recognition.Text.text (snet.speech-recognition.s2t (snet.speech-recognition.MkAudio (S' (S' Z')))))))))) (snet.sound-spleeter.Output.vocals (S' Z')))) (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") Z')))) (-> Bytes Bytes)))

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let* (($spleeter-output (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input)))
;;           ($english-vocals (snet.sound-spleeter.Output.vocals $spleeter-output))
;;           ($chinese-lyrics (naint.machine-translation.Output.translation
;;                             (naint.machine-translation.translate
;;                              (((naint.machine-translation.MkInput "English") "Chinese")
;;                               (snet.speech-recognition.Text.text
;;                                (snet.speech-recognition.s2t
;;                                 (snet.speech-recognition.MkAudio $english-vocals)))))))
;;           ($midi-notes (tomidi.MIDI.data (tomidi.a2m (tomidi.MkAudio $english-vocals))))
;;           ($chinese-vocals (naint.midi2voice-zh.Answer.output_audio
;;                             (naint.midi2voice-zh.singingZH
;;                              (((naint.midi2voice-zh.MkQuery $chinese-lyrics) $midi-notes) 1.0)))))
;;      (mixer.Audio.data
;;       (mixer.mix
;;        ((mixer.MkMultiAudio (snet.sound-spleeter.Output.accomp $spleeter-output)) $chinese-vocals)))))

;; The following MeTTa program represents the AI service composition
;; for the English to Chinese song translation, but uses let instead
;; of let*.
;;
;; (= (english-song-to-chinese-song $input)
;;    (let $spleeter-output (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))
;;      (let $english-vocals (snet.sound-spleeter.Output.vocals $spleeter-output)
;;        (let $chinese-lyrics (naint.machine-translation.Output.translation
;;                              (naint.machine-translation.translate
;;                               (((naint.machine-translation.MkInput "English") "Chinese")
;;                                (snet.speech-recognition.Text.text
;;                                 (snet.speech-recognition.s2t
;;                                  (snet.speech-recognition.MkAudio $english-vocals))))))
;;          (let $midi-notes (tomidi.MIDI.data (tomidi.a2m (tomidi.MkAudio $english-vocals)))
;;            (let $chinese-vocals (naint.midi2voice-zh.Answer.output_audio
;;                                  (naint.midi2voice-zh.singingZH
;;                                   (((naint.midi2voice-zh.MkQuery $chinese-lyrics) $midi-notes) 1.0)))
;;              (mixer.Audio.data
;;               (mixer.mix
;;                ((mixer.MkMultiAudio (snet.sound-spleeter.Output.accomp $spleeter-output)) $chinese-vocals)))))))))

;; The following lambda term has been obtained by converting MeTTa to
;; lambda-calculus using mt2lc defined in the chaining repository.

;; (= (english-song-to-chinese-song $input)
;;    (((λ $spleeter-output)
;;      (((λ $english-vocals)
;;        (((λ $chinese-lyrics)
;;          (((λ $midi-notes)
;;            (((λ $chinese-vocals)
;;              (mixer.Audio.data
;;               (mixer.mix ((mixer.MkMultiAudio (snet.sound-spleeter.Output.accomp $spleeter-output))
;;                           $chinese-vocals))))
;;             (naint.midi2voice-zh.Answer.output_audio
;;              (naint.midi2voice-zh.singingZH
;;               (((naint.midi2voice-zh.MkQuery $chinese-lyrics)
;;                 $midi-notes)
;;                1.0)))))
;;           (tomidi.MIDI.data (tomidi.a2m (tomidi.MkAudio $english-vocals)))))
;;         (naint.machine-translation.Output.translation
;;          (naint.machine-translation.translate (((naint.machine-translation.MkInput "English") "Chinese")
;;                                                (snet.speech-recognition.Text.text
;;                                                 (snet.speech-recognition.s2t
;;                                                  (snet.speech-recognition.MkAudio $english-vocals))))))))
;;       (snet.sound-spleeter.Output.vocals $spleeter-output)))
;;     (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb (Cons (: (S' Z') $t51913082) Nil) Z' (fromNumber 1)
      (: (snet.sound-spleeter.Output.accomp (: (S' Z') $t51913082)) $t51898733))
  (: (snet.sound-spleeter.Output.accomp
      (: (S' Z') snet.sound-spleeter.Output)) Bytes))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb (Cons (: (S' Z') $t51913082) Nil) Z' (fromNumber 2)
      (: (mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                                 (: (S' Z') $t51913082)) $t51898733)) $thrm))
  (: (mixer.MkMultiAudio
      (: (snet.sound-spleeter.Output.accomp
          (: (S' Z') snet.sound-spleeter.Output)) Bytes))
     (-> Bytes mixer.MultiAudio)))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') $t51913082)
            (Cons (: (S' (S' (S' (S' (S' Z'))))) $t51880775) Nil))
      Z'
      (fromNumber 2)
      (: (mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                                 (: (S' Z') $t51913082))
                                $t51898733))
         $thrm))
  (: (mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                             (: (S' Z') snet.sound-spleeter.Output)) Bytes))
     (-> Bytes mixer.MultiAudio)))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') Bytes) (Cons (: Z' snet.sound-spleeter.Output) Nil))
      Z'
      (fromNumber 3)
      (: ((mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                                  (: Z' snet.sound-spleeter.Output)) Bytes))
          (: (S' Z') Bytes))
         $thrm))
  (: ((mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                              (: Z' snet.sound-spleeter.Output)) Bytes))
      (: (S' Z') Bytes))
     mixer.MultiAudio))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: Z' $t51913082) (Cons (: (S' Z') $t51880775) Nil))
      Z'
      (fromNumber 3)
      (: ((mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                                  (: Z' $t51913082)) $t51898733))
          (: (S' Z') $t51880775))
         $thrm))
  (: ((mixer.MkMultiAudio (: (snet.sound-spleeter.Output.accomp
                              (: Z' snet.sound-spleeter.Output)) Bytes))
      (: (S' Z') Bytes))
     mixer.MultiAudio))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') $t51913082)
            (Cons (: (S' (S' (S' (S' (S' Z'))))) $t51880775) Nil))
      Z'
      (fromNumber 4)
      (: (mixer.mix
          (: ((mixer.MkMultiAudio
               (: (snet.sound-spleeter.Output.accomp
                   (: (S' Z') $t51913082)) $t51898733))
              (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
             $t51855788))
         $t51829490))
  (: (mixer.mix
      (: ((mixer.MkMultiAudio
           (: (snet.sound-spleeter.Output.accomp
               (: (S' Z') snet.sound-spleeter.Output)) Bytes))
          (: (S' (S' (S' (S' (S' Z'))))) Bytes))
         mixer.MultiAudio))
     mixer.Audio))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') $t51913082)
            (Cons (: (S' (S' (S' (S' (S' Z'))))) $t51880775) Nil))
      Z'
      (fromNumber 5)
      (: (mixer.Audio.data
          (: (mixer.mix
              (: ((mixer.MkMultiAudio
                   (: (snet.sound-spleeter.Output.accomp
                       (: (S' Z') $t51913082)) $t51898733))
                  (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
                 $t51855788)) $t51829490))
         $thrm))
  (: (mixer.Audio.data
      (: (mixer.mix
          (: ((mixer.MkMultiAudio
               (: (snet.sound-spleeter.Output.accomp
                   (: (S' Z') snet.sound-spleeter.Output)) Bytes))
              (: (S' (S' (S' (S' (S' Z'))))) Bytes))
             mixer.MultiAudio)) mixer.Audio))
     Bytes))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') $t51913082) Nil)
      (S' (S' (S' (S' (S' Z')))))
      (fromNumber 6)
      (: (λ (S' (S' (S' (S' (S' Z')))))
           (mixer.Audio.data
            (: (mixer.mix
                (: ((mixer.MkMultiAudio
                     (: (snet.sound-spleeter.Output.accomp
                         (: (S' Z') $t51913082)) $t51898733))
                    (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
                   $t51855788)) $t51829490)))
         $thrm))
  (: (λ (S' (S' (S' (S' (S' Z')))))
       (mixer.Audio.data
        (: (mixer.mix
            (: ((mixer.MkMultiAudio
                 (: (snet.sound-spleeter.Output.accomp
                     (: (S' Z') snet.sound-spleeter.Output)) Bytes))
                (: (S' (S' (S' (S' (S' Z'))))) Bytes))
               mixer.MultiAudio)) mixer.Audio)))
     (-> Bytes Bytes)))

;; Type check a portion of the English to Chinese singing AI service composition
!(assertEqual
  (bc &kb
      (Cons (: (S' Z') $t51913082)
            (Cons (: (S' (S' (S' Z'))) $t52151099)
                  (Cons (: (S' (S' (S' (S' Z')))) $t52131583) Nil)))
      (S' (S' (S' (S' (S' Z')))))
      (fromNumber 7)
      (: ((λ (S' (S' (S' (S' (S' Z')))))
            (mixer.Audio.data
             (: (mixer.mix
                 (: ((mixer.MkMultiAudio
                      (: (snet.sound-spleeter.Output.accomp
                          (: (S' Z') $t51913082)) $t51898733))
                     (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
                    $t51855788)) $t51829490)))
          (: (naint.midi2voice-zh.Answer.output_audio
              (: (naint.midi2voice-zh.singingZH
                  (: (((naint.midi2voice-zh.MkQuery
                        (: (S' (S' (S' Z'))) $t52151099))
                       (: (S' (S' (S' (S' Z')))) $t52131583))
                      (: 1.0 $t52104485))
                     $t52075637))
                 $t52045478))
             $t51726536))
         $thrm))
  (: ((λ (S' (S' (S' (S' (S' Z')))))
        (mixer.Audio.data
         (: (mixer.mix
             (: ((mixer.MkMultiAudio
                  (: (snet.sound-spleeter.Output.accomp
                      (: (S' Z') snet.sound-spleeter.Output)) Bytes))
                 (: (S' (S' (S' (S' (S' Z'))))) Bytes))
                mixer.MultiAudio)) mixer.Audio)))
      (: (naint.midi2voice-zh.Answer.output_audio
          (: (naint.midi2voice-zh.singingZH
              (: (((naint.midi2voice-zh.MkQuery
                    (: (S' (S' (S' Z'))) String))
                   (: (S' (S' (S' (S' Z')))) Bytes))
                  (: 1.0 Float))
                 naint.midi2voice-zh.Query))
             naint.midi2voice-zh.Answer))
         Bytes))
     Bytes))

;; ;; Type check a portion of the English to Chinese singing AI service composition
;; Disabled because it takes a long time
;; !(assertEqual
;;   (bc &kb
;;       (Cons (: (S' Z') $t51913082)
;;             (Cons (: (S' (S' (S' Z'))) $t52151099) Nil))
;;       (S' (S' (S' (S' Z'))))
;;       (fromNumber 8)
;;       (: (λ (S' (S' (S' (S' Z'))))
;;            ((λ (S' (S' (S' (S' (S' Z')))))
;;               (mixer.Audio.data
;;                (: (mixer.mix
;;                    (: ((mixer.MkMultiAudio
;;                         (: (snet.sound-spleeter.Output.accomp
;;                             (: (S' Z') $t51913082)) $t51898733))
;;                        (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
;;                       $t51855788)) $t51829490)))
;;             (: (naint.midi2voice-zh.Answer.output_audio
;;                 (: (naint.midi2voice-zh.singingZH
;;                     (: (((naint.midi2voice-zh.MkQuery
;;                           (: (S' (S' (S' Z'))) $t52151099))
;;                          (: (S' (S' (S' (S' Z')))) $t52131583))
;;                         (: 1.0 $t52104485))
;;                        $t52075637))
;;                    $t52045478))
;;                $t51726536)))
;;          $thrm))
;;   (: (λ (S' (S' (S' (S' Z'))))
;;        ((λ (S' (S' (S' (S' (S' Z')))))
;;           (mixer.Audio.data
;;            (: (mixer.mix
;;                (: ((mixer.MkMultiAudio
;;                     (: (snet.sound-spleeter.Output.accomp
;;                         (: (S' Z') snet.sound-spleeter.Output)) Bytes))
;;                    (: (S' (S' (S' (S' (S' Z'))))) Bytes))
;;                   mixer.MultiAudio)) mixer.Audio)))
;;         (: (naint.midi2voice-zh.Answer.output_audio
;;             (: (naint.midi2voice-zh.singingZH
;;                 (: (((naint.midi2voice-zh.MkQuery
;;                       (: (S' (S' (S' Z'))) String))
;;                      (: (S' (S' (S' (S' Z')))) Bytes))
;;                     (: 1.0 Float))
;;                    naint.midi2voice-zh.Query))
;;                naint.midi2voice-zh.Answer))
;;            Bytes)))
;;      (-> Bytes Bytes)))

;; ;; Type check a portion of the English to Chinese singing AI service composition
;; Disabled because it takes a long tim
;; !(assertEqual
;;   (bc &kb
;;       (Cons (: (S' Z') $t51913082)
;;             (Cons (: (S' (S' Z')) $t52945476)
;;                   (Cons (: (S' (S' (S' Z'))) $t52151099) Nil)))
;;       (S' (S' (S' (S' Z'))))
;;       (fromNumber 9)
;;       (: ((λ (S' (S' (S' (S' Z'))))
;;             ((λ (S' (S' (S' (S' (S' Z')))))
;;                (mixer.Audio.data
;;                 (: (mixer.mix
;;                     (: ((mixer.MkMultiAudio
;;                          (: (snet.sound-spleeter.Output.accomp
;;                              (: (S' Z') $t51913082)) $t51898733))
;;                         (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
;;                        $t51855788)) $t51829490)))
;;              (: (naint.midi2voice-zh.Answer.output_audio
;;                  (: (naint.midi2voice-zh.singingZH
;;                      (: (((naint.midi2voice-zh.MkQuery
;;                            (: (S' (S' (S' Z'))) $t52151099))
;;                           (: (S' (S' (S' (S' Z')))) $t52131583))
;;                          (: 1.0 $t52104485))
;;                         $t52075637))
;;                     $t52045478))
;;                 $t51726536)))
;;           (: (tomidi.MIDI.data
;;               (: (tomidi.a2m
;;                   (: (tomidi.MkAudio
;;                       (: (S' (S' Z')) $t52945476))
;;                      $t52929564))
;;                  $t12345678))
;;              $t51422971))
;;          $thrm))
;;   (: ((λ (S' (S' (S' (S' Z'))))
;;         ((λ (S' (S' (S' (S' (S' Z')))))
;;            (mixer.Audio.data
;;             (: (mixer.mix
;;                 (: ((mixer.MkMultiAudio
;;                      (: (snet.sound-spleeter.Output.accomp
;;                          (: (S' Z') snet.sound-spleeter.Output)) Bytes))
;;                     (: (S' (S' (S' (S' (S' Z'))))) Bytes))
;;                    mixer.MultiAudio)) mixer.Audio)))
;;          (: (naint.midi2voice-zh.Answer.output_audio
;;              (: (naint.midi2voice-zh.singingZH
;;                  (: (((naint.midi2voice-zh.MkQuery
;;                        (: (S' (S' (S' Z'))) String))
;;                       (: (S' (S' (S' (S' Z')))) Bytes))
;;                      (: 1.0 Float))
;;                     naint.midi2voice-zh.Query))
;;                 naint.midi2voice-zh.Answer))
;;             Bytes)))
;;       (: (tomidi.MIDI.data
;;           (: (tomidi.a2m
;;               (: (tomidi.MkAudio
;;                   (: (S' (S' Z')) Bytes))
;;                  tomidi.Audio))
;;              tomidi.MIDI))
;;          Bytes))
;;      Bytes))

;; Type check the totality of the English to Chinese singing AI service composition
;; Disabled because it takes several hours
;; !(bc &kb Nil Z' (fromNumber 16)
;;      (: (λ Z'
;;           ((λ (S' Z')
;;              ((λ (S' (S' Z'))
;;                 ((λ (S' (S' (S' Z')))
;;                    ((λ (S' (S' (S' (S' Z'))))
;;                       ((λ (S' (S' (S' (S' (S' Z')))))
;;                          (mixer.Audio.data
;;                           (: (mixer.mix
;;                               (: ((mixer.MkMultiAudio
;;                                    (: (snet.sound-spleeter.Output.accomp
;;                                        (: (S' Z') $t51913082)) $t51898733))
;;                                   (: (S' (S' (S' (S' (S' Z'))))) $t51880775))
;;                                  $t51855788)) $t51829490)))
;;                        (: (naint.midi2voice-zh.Answer.output_audio
;;                            (: (naint.midi2voice-zh.singingZH
;;                                (: (((naint.midi2voice-zh.MkQuery
;;                                      (: (S' (S' (S' Z'))) $t52151099))
;;                                     (: (S' (S' (S' (S' Z')))) $t52131583))
;;                                    (: 1.0 $t52104485))
;;                                   $t52075637))
;;                               $t52045478))
;;                           $t51726536)))
;;                     (: (tomidi.MIDI.data
;;                         (: (tomidi.a2m
;;                             (: (tomidi.MkAudio
;;                                 (: (S' (S' Z')) $t52945476))
;;                                $t52929564))
;;                            $t12345678))
;;                        $t51422971)))
;;                  (: (naint.machine-translation.Output.translation
;;                      (: (naint.machine-translation.translate
;;                          (: (((naint.machine-translation.MkInput
;;                                (: "English" $t56254732))
;;                               (: "Chinese" $t56245878))
;;                              (: (snet.speech-recognition.Text.text
;;                                  (: (snet.speech-recognition.s2t
;;                                      (: (snet.speech-recognition.MkAudio
;;                                          (: (S' (S' Z')) $t56315149))
;;                                         $t56299237))
;;                                     $t56282014))
;;                                 $t56230536))
;;                             $t56207979))
;;                         $t56184111))
;;                     $t50404647)))
;;               (: (snet.sound-spleeter.Output.vocals
;;                   (: (S' Z') $t70938935)) $t46608723)))
;;            (: (snet.sound-spleeter.spleeter
;;                (: ((snet.sound-spleeter.MkInput
;;                     (: "" $t131081238))
;;                    (: Z' $t131072410))
;;                   $t131058283))
;;               $t31783546)))
;;         (-> Bytes Bytes)))
